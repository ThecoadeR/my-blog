<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript 之面向对象 | 前端打杂师 - Zhu</title>
    <meta name="description" content="All is well">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="/vue-press/image/favicon.ico">
    
    <link rel="preload" href="/vue-press/assets/css/0.styles.309fb19c.css" as="style"><link rel="preload" href="/vue-press/assets/js/app.b5758dc3.js" as="script"><link rel="preload" href="/vue-press/assets/js/2.84534382.js" as="script"><link rel="preload" href="/vue-press/assets/js/4.a9e0ce27.js" as="script"><link rel="prefetch" href="/vue-press/assets/js/10.a8f9d8fb.js"><link rel="prefetch" href="/vue-press/assets/js/11.59af9ad4.js"><link rel="prefetch" href="/vue-press/assets/js/12.652d610e.js"><link rel="prefetch" href="/vue-press/assets/js/13.92fded10.js"><link rel="prefetch" href="/vue-press/assets/js/14.c0d081f2.js"><link rel="prefetch" href="/vue-press/assets/js/15.c0ffea54.js"><link rel="prefetch" href="/vue-press/assets/js/16.3fc55a53.js"><link rel="prefetch" href="/vue-press/assets/js/17.3bf113dd.js"><link rel="prefetch" href="/vue-press/assets/js/18.a48c1f76.js"><link rel="prefetch" href="/vue-press/assets/js/3.7d025fd1.js"><link rel="prefetch" href="/vue-press/assets/js/5.d87cfe99.js"><link rel="prefetch" href="/vue-press/assets/js/6.73226d87.js"><link rel="prefetch" href="/vue-press/assets/js/7.f86b5ded.js"><link rel="prefetch" href="/vue-press/assets/js/8.adf5f1a8.js"><link rel="prefetch" href="/vue-press/assets/js/9.cb3da39a.js">
    <link rel="stylesheet" href="/vue-press/assets/css/0.styles.309fb19c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-press/" class="home-link router-link-active"><!----> <span class="site-name">前端打杂师 - Zhu</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vue-press/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vue-press/JS/Base.html" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="https://github.com/ThecoadeR/vue-press/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vue-press/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vue-press/JS/Base.html" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="https://github.com/ThecoadeR/vue-press/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>VuePress</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press/JS/Base.html" class="sidebar-link">JavaScript 基础</a></li><li><a href="/vue-press/JS/" class="sidebar-link">JavaScript 之原型链</a></li><li><a href="/vue-press/JS/OOP.html" class="active sidebar-link">JavaScript 之面向对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-press/JS/OOP.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/vue-press/JS/OOP.html#类的声明方式以及实例化" class="sidebar-link">类的声明方式以及实例化</a></li><li class="sidebar-sub-header"><a href="/vue-press/JS/OOP.html#继承" class="sidebar-link">继承</a></li><li class="sidebar-sub-header"><a href="/vue-press/JS/OOP.html#未完待续" class="sidebar-link">未完待续...</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue.js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Electron</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端代码规范</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端面试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>随手记</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="javascript-之面向对象"><a href="#javascript-之面向对象" class="header-anchor">#</a> JavaScript 之面向对象</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>众所周知 JavaScript 万物皆可对象 这一篇博客 就来讲讲 JS 中面向对象的那些事儿 既然要面向对象 那么首先要想到的第一件事就是 <code>类</code> 没有这些类 哪儿来的对象是不是 所以 先来看看创建类的方式吧</p> <h2 id="类的声明方式以及实例化"><a href="#类的声明方式以及实例化" class="header-anchor">#</a> 类的声明方式以及实例化</h2> <p>类的创建方式有两种 一种就是<code>构造函数</code> 另一种就是 ES6 新推出的<code>class</code> 不过 class 其实也是通过构造函数去新建一个类 其实个人感觉两者大同小异吧 下面来看代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES5 构造函数创建类</span>
<span class="token keyword">function</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES6 通过class新建一个类</span>
<span class="token keyword">class</span> <span class="token class-name">Plane</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 通过类实例化一个对象</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token string">'BMW'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Plane</span><span class="token punctuation">(</span><span class="token string">'Boeing747'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h2> <p>谈到类 那肯定绕不开的就是继承 在 JS 中继承的方式也分两种 一种是通过构造函数继承 也就是改变构造函数的 this 指向来继承 另一种是通过原型链继承 两种方法也算是各有利弊 先来看代码 再来说两种方法的利弊吧</p> <ul><li>通过构造函数继承</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 通过构造函数继承</span>
<span class="token keyword">function</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'汽车'</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token constant">BMW</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Car</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'BMW'</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> <span class="token constant">M2</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BMW</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">M2</span><span class="token punctuation">)</span>
</code></pre></div><p><img src="/vue-press/assets/img/console1.6a204d65.jpg" alt=""></p> <p>从控制台里我们可以看到<code>M2</code>这个实例包含了两个属性 一个是 type 属性 一个是 name 属性 但是很明显的是 BMW 这个构造函数里并没有<code>type</code> 只有一句<code>Car.apply(this)</code> 其实也正是这行代码 让 BMW 这个构造函数继承了 Car 构造函数里的所有属性和方法</p> <p>众所周知 JS 里有<code>call</code>和<code>apply</code>这两个方法 这两个方法的主要目的也就是改变函数的执行上下文 也就是<code>this指向</code> 而上面的代码 我们在 BMW 这个构造函数里引用了 Car 这个函数 同时更改了 Car 这个函数里的 this 指向 将原本指向 Car 的 this 全部指向了 BMW 所以 Car 这个构造函数里的所有属性全部被 BMW 这个构造函数所继承 这样的继承有个小问题 就是 它只能继承构造函数里的一些属性和方法 如果是原型链上的 就没办法继承 可以通过代码一起来看一下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 假设Car的原型链上有一个play方法</span>
<span class="token class-name">Car</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">play</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am a Car'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> car <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
car<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// M2延用之前通过BMW创建的实例</span>
<span class="token constant">M2</span><span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p><img src="/vue-press/assets/img/console2.16cf72d7.jpg" alt=""></p> <p>可以看到实例 M2 并没有继承 Car 原型链上的一些方法 根本原因还是在于 由于是构造函数继承的 也就是改变了<code>this</code>的指向 也就是只能继承构造函数体里的内容 而无法继承 原型链上的内容</p> <p>那么 接下去来讲讲原型链上的继承吧</p> <ul><li>通过原型链继承</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'parent2'</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Child2'</span>
<span class="token punctuation">}</span>
child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
</code></pre></div><p><img src="/vue-press/assets/img/console3.51e10443.jpg" alt=""></p> <p>从控制台可以看到 c 这个实例 它的<code>__proto__</code>指向了它的父元素 Parent 而不是<code>Object</code> 也就是说 c 这个实例通过原型链继承自 Parent 那这是为什么呢</p> <p>其根本原理还是绕不开原型链 我们都知道实例和原型链之间是通过<code>__proto__</code>关联 在上文代码中 我们将 Child 的<code>__proto___</code>指向了 Parent 也就是说 <code>Parent.__proto === Child.__proto___</code> 也可以理解成 这两者 都指向了同一个原型对象 那么自然而然也会继承这个原型对象下的所有方法和属性 不过这样的继承方法 其实也有坑 因为原型对象下的所有方法和属性都被实例共享了 那么一旦某个实例更改了共有的属性或者方法 其他实例也会跟着更改 我们来看代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">parent2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'parent'</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>play <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">child2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'child2'</span>
<span class="token punctuation">}</span>
child2<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">parent2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">child2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">child2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
c1<span class="token punctuation">.</span>play<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span>play<span class="token punctuation">,</span> c2<span class="token punctuation">.</span>play<span class="token punctuation">)</span>
</code></pre></div><p><img src="/vue-press/assets/img/console4.39dc08bb.jpg" alt=""></p> <p>可以看到c1和c2这两个实例 统统都是继承自parent2 我们只在c1里对play这个数组进行了push的操作 但是c2里的play也跟着进行了变化 这显然不是我们希望看到的 我们希望看到的是 实例之间的属性都是相隔离的 而不是会相互污染的</p> <h2 id="未完待续"><a href="#未完待续" class="header-anchor">#</a> 未完待续...</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue-press/JS/" class="prev router-link-active">
        JavaScript 之原型链
      </a></span> <span class="next"><a href="/vue-press/Vue/">
        Vue过渡动画原理解析
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vue-press/assets/js/app.b5758dc3.js" defer></script><script src="/vue-press/assets/js/2.84534382.js" defer></script><script src="/vue-press/assets/js/4.a9e0ce27.js" defer></script>
  </body>
</html>
