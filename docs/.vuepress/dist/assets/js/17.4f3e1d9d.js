(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{233:function(e,a,s){"use strict";s.r(a);var c=s(28),t=Object(c.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"webpack是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack是什么"}},[e._v("#")]),e._v(" webpack是什么?")]),e._v(" "),s("p",[e._v("关于webpack是什么 其实这个问题也很好解答 只需要打开webpack的官网 首先映入眼帘便是这么一段话 "),s("code",[e._v("webpack is a module bundler")]),e._v(" 翻译过来就是 webpack是一个"),s("code",[e._v("模块打包工具")]),e._v(" 也就是说 当我们的项目工程变得非常庞大的时候 我们可以将项目拆分成一个个的模块 同时借助webpack帮助我们打包最后整合在一起 这样可以便于后期的维护和迭代")]),e._v(" "),s("h2",{attrs:{id:"webpack的安装"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack的安装"}},[e._v("#")]),e._v(" webpack的安装")]),e._v(" "),s("p",[e._v("关于webpack的安装 其实也就是通过npm安装 只需要一行命令 简单粗暴 值得注意的一点是 webpack最好是不要全局安装 否则容易引起因为webpack版本的问题 从而使得互相依赖的两个项目有冲突\n安装命令: "),s("code",[e._v("npm install webpack webpack-cli -D")]),e._v(" 安装好以后 在命令行工具里输入 "),s("code",[e._v("npx webpack -v")]),e._v(" 如果正确显示版本号 那么就是成功安装了webpack")]),e._v(" "),s("h2",{attrs:{id:"关于webpack-cli"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于webpack-cli"}},[e._v("#")]),e._v(" 关于webpack-cli")]),e._v(" "),s("p",[e._v("听起来像是像是一个webpack的脚手架工具是不是? 其实webpack-cli最大的作用在于 帮助我们可以在命令行里 可以直接使用webpack这个命令 例如 借助node提供的npx 可以直接在命令行里进入项目 "),s("code",[e._v("npx webpack")])]),e._v(" "),s("h2",{attrs:{id:"webpack打包命令简化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack打包命令简化"}},[e._v("#")]),e._v(" webpack打包命令简化")]),e._v(" "),s("p",[e._v("写过vue的同学应该很熟悉这个命令 "),s("code",[e._v("npm run dev/start")]),e._v(" 其实就是通过项目里"),s("code",[e._v("package.json")]),e._v("文件下的npm scripts来改变了原先的webpack打包命令")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/6/169f0bdfebb2e2e5?w=534&h=152&f=png&s=58678",alt:""}}),e._v(" 其中 键"),s("code",[e._v("dev")]),e._v("表示的就是打包的命令 值就是一些打包的规则 后面会讲到")]),e._v(" "),s("h2",{attrs:{id:"webpack的loader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack的loader"}},[e._v("#")]),e._v(" webpack的loader")]),e._v(" "),s("p",[e._v("webpack其实只认识js工具 也就是说webpack只会自动识别.js后缀为结尾的文件 清楚该怎么打包js文件 但是随着项目的不断扩展 只有js文件是肯定不行的 所以这个时候 我们就需要借助各种各样的loader来帮助我们告诉webpack 这个是个什么文件 这个文件要怎么打包 这也就是loader的概念")]),e._v(" "),s("p",[e._v("现在假设 我们的项目下 有一个"),s("code",[e._v("index.js")]),e._v("文件 和一个 "),s("code",[e._v("index.css文件")]),e._v(" 同时你在"),s("code",[e._v("index.js")]),e._v("文件里通过"),s("code",[e._v("import")]),e._v("或者"),s("code",[e._v("require")]),e._v("的方式引入了"),s("code",[e._v("index.css")]),e._v(" 这个时候你想让webpack打包 那么一定是会报错的 所以我们需要借助一些loader来帮助我们 —— "),s("code",[e._v("style-loader")]),e._v(" 和 "),s("code",[e._v("css-loader")])]),e._v(" "),s("p",[e._v("这两个loader首先通过npm install 安装在项目里 同时在项目里新建一个webpack.config.js文件 做好如下配置 就可以让webpack知道该如何打包.css文件了 是不是很简单")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/6/169f0d201397e091?w=360&h=182&f=png&s=68578",alt:""}})]),e._v(" "),s("p",[e._v("其中 键 "),s("code",[e._v("test")]),e._v("对应的是一个正则 也就是是什么后缀的文件 键 "),s("code",[e._v("use")]),e._v("对应的数组就是 使用哪一些loader")]),e._v(" "),s("h2",{attrs:{id:"loader之间的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#loader之间的关系"}},[e._v("#")]),e._v(" loader之间的关系")]),e._v(" "),s("p",[e._v("关于这些loader的关系其实 首先css-loader帮助我们梳理各个css之间的关系 然后 style-css帮助我们将css文件挂载到index.html文件的头部")]),e._v(" "),s("h2",{attrs:{id:"postcss-loader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#postcss-loader"}},[e._v("#")]),e._v(" postcss-loader")]),e._v(" "),s("p",[e._v("这个loader其实就是 借助"),s("code",[e._v("autoprefixer")]),e._v("帮助我们自动添加厂商前缀 使用这个loader的话 还需要配置一个额外postcss.config.js文件\n"),s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/6/169f0e34e86a603e?w=462&h=196&f=png&s=55364",alt:""}})]),e._v(" "),s("h2",{attrs:{id:"plugins"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#plugins"}},[e._v("#")]),e._v(" plugins")]),e._v(" "),s("p",[e._v("plugins 翻译过来就是插件 webpack也提供了非常多的插件 来帮助我们在webpack打包的时候 自动的做一些事情 这里介绍两个插件")]),e._v(" "),s("p",[e._v("① "),s("code",[e._v("clean-webpack-plugin")]),e._v(" 这个插件的作用在于 可以在我们每次打包之前 删除掉原先打包好的文件 具体使用方法 先通过npm install安装该插件 然后在webpack配置文件里 引入这个插件\n"),s("code",[e._v("const CleanWebpackPlugin = require('clean-webpack-plugin')")]),e._v("\n最后在wepback的plugins这个字段里 新建一个实例"),s("code",[e._v("plugins: [ new CleanWebpackPlugin({ cleanStaleWebpackAssets: true })")])]),e._v(" "),s("p",[e._v("② HotModuleReplacementPlugin  看名字其实也就很简单粗暴了 也就是热更新 也就是 当代码变化的时候你不需要手动刷新页面 他可以自动帮你刷新页面 是不是还挺方便  具体配置的话 其实基本和第一个插件大同小异 先安装 然后引入 最后new一个实例就好了\n"),s("code",[e._v("new webpack.HotModuleReplacementPlugin()")])]),e._v(" "),s("h2",{attrs:{id:"devserver"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#devserver"}},[e._v("#")]),e._v(" devServer")]),e._v(" "),s("p",[e._v("通过配置devServer可以快速在本地构建一个http服务器 首先 你需要在package.json的scripts字段下 新增一条webpack打包的规则")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/6/169f0f8e523a6f33?w=516&h=146&f=png&s=53554",alt:""}}),e._v("\n当然 光有这个东西是不够的 你还需要在webpack配置文件里 配置一下这个devServer 具体配置如下\n"),s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/6/169f0f9c7ee22a84?w=390&h=142&f=png&s=55125",alt:""}})])])}),[],!1,null,null,null);a.default=t.exports}}]);